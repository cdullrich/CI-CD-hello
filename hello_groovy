node('master')
{
    timestamps{
        try {
            stage ('Cleanup Workspace') {
                echo "Cleaning workspace: ${env.WORKSPACE}"
                deleteDir()
                try{
                sh 'sudo docker stop $(docker ps -aq)'
                sh 'sudo docker rm $(docker ps -aq)'
                sh 'sudo docker rmi -f $(docker images -q)'
                sh 'sudo docker system prune -af'
                }
                catch (err) {
                    echo "while cleaning images: ${err}"
                }
            }
            stage ('Checkout Hello Code')
            {
                echo "checking out code"
                git url: 'https://github.com/cdullrich/CI-CD-hello/'
            }
            stage ('build Go code')
            {
                echo "building application"
                sh 'go get github.com/gorilla/mux'
                sh 'env GOOS=linux GOARCH=amd64 go build -o HomeAdvisor'
            }
            stage ('dockerize build')
            {
                withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'RedHatDocker', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]){
                    echo "dockerizing build"
                    sh 'docker login registry.redhat.io -u ${USERNAME} -p ${PASSWORD}'
                    sh 'sudo -s docker build -t hello-advisor .'
                }
            }
            stage ('test build')
            {
                sh 'sudo -s docker run -d -p 30000:30000 hello-advisor'
                echo "Waiting and verifying build's expected http response"
                sh 'sleep 5'
                def http_test = ''
                http_test = sh(script: 'curl http://localhost:30000', returnStdout: true).trim()
                echo "The response to the API follows-"
                echo "${http_test}" 
                if (http_test != 'Hello, HomeAdvisor!') {
                    error "Pipeline aborted due to failed GoLang API test. HTTP content from test: ${http_test}"
                }
            }
            stage ('publish to artifactory')
            {
                echo "we don't actually have artifactory linked up, but we would probably build compiled code to it here"
            }
            stage ('push docker image')
            {
                echo "pushing docker image"
                sh 'sudo -s docker tag hello-advisor:latest 742886329884.dkr.ecr.us-east-1.amazonaws.com/cdu-containers:latest'
                sudo 'sudo -s docker push 742886329884.dkr.ecr.us-east-1.amazonaws.com/cdu-containers:latest'
            }
            stage ('deploy to kubernetes cluster')
            {
                echo "deploying build to production"
                sh 'kubectl run cdu-hello-advisor --image=742886329884.dkr.ecr.us-east-1.amazonaws.com/cdu-containers:latest --requests=cpu=500m --expose --port=30000'
                sh 'kubectl autoscale deployment cdu-hello-advisor --cpu-percent=50 --min=1 --max=10'
                try {
                    sh 'kubectl expose deployment cdu-hello-advisor --type=LoadBalancer --name=hello-advisor-endpoint'
                }
                catch (err) {
                    sh 'kubectl annotate services hello-advisor-endpoint service.beta.kubernetes.io/aws-load-balancer-internal=‚Äù0.0.0.0/0"'
                }
            }
        }
        catch (err) {
            echo "woopsie doopsie: ${err}"
            echo "cleaning up docker images and containers"
            sh 'sudo docker system prune -af'
            currentBuild.result = 'FAILURE'
        }
    }
}